import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:vortex_cli/utils/logger.dart';

import '../../interface/command.dart';

class RunnerCommand extends Command {
  @override
  String get commandName => 'runner';

  @override
  List<String> get alias => ['module', '-p', '-m'];

  @override
  Future<void> execute() async {
    final pagesDir =
        flags.contains('pages-dir') ? _getArgValue('pages-dir') : 'lib/pages';
    final verbose =
        flags.contains('verbose') || flags.contains('-v') ? true : false;

    LogService.info("Running Vortex router scanner...");
    final projectDir = Directory.current.path;
    LogService.info("Project directory: $projectDir");
    final fullPagesDir = path.join(projectDir, pagesDir);
    LogService.info("Pages directory: $fullPagesDir");
    // Check if the pages directory exists
    if (!Directory(fullPagesDir).existsSync()) {
      LogService.error("Pages directory not found: $fullPagesDir");
      return;
    }

    try {
      // Scan for page files
      final pageFiles = _findPageFiles(fullPagesDir);
      LogService.info("Found ${pageFiles.length} page files");

      if (verbose) {
        for (final file in pageFiles) {
          LogService.info(
            "Page file: ${path.relative(file.path, from: projectDir)}",
          );
        }
      }

      // Generate the route registration code
      _generateRouteRegistration(projectDir, pageFiles);

      LogService.info("FlutterWind router scanner completed successfully");
    } catch (e, stackTrace) {
      LogService.error(
        "Error running router scanner, error: $e, stackTrace: $stackTrace",
      );
    }
  }

  @override
  String? get codeSample => '';

  @override
  String? get hint => 'vortex runner';

  @override
  int get maxParameters => 0;

  String _getArgValue(String flag) {
    final index = flags.indexOf(flag);
    if (index != -1 && index < flags.length - 1) {
      return flags[index + 1];
    }
    return '';
  }

  List<File> _findPageFiles(String directory) {
    return Directory(directory)
        .listSync(recursive: true)
        .where(
          (entity) =>
              entity is File &&
              entity.path.endsWith('.dart') &&
              _containsPageAnnotation(entity),
        )
        .cast<File>()
        .toList();
  }

  /// Check if a file contains the FlutterWindPage annotation
  bool _containsPageAnnotation(File file) {
    try {
      final content = file.readAsStringSync();
      return content.contains('@FlutterWindPage');
    } catch (e) {
      LogService.error("Error reading file: ${file.path}, error: $e");
      return false;
    }
  }

  /// Get the package name from pubspec.yaml
String _getPackageName(String projectDir) {
  try {
    final pubspecFile = File(path.join(projectDir, 'pubspec.yaml'));

    if (pubspecFile.existsSync()) {
      final content = pubspecFile.readAsStringSync();
      final nameMatch = RegExp(r'name:\s*([^\s]+)').firstMatch(content);
      if (nameMatch != null) {
        return nameMatch.group(1)!;
      }
    }
  } catch (e) {
    LogService.error("Error getting package name, error: $e");
  }

  return 'app';
}

  /// Generate route registration code
  void _generateRouteRegistration(String projectDir, List<File> pageFiles) {
    try {
      final outputDir = path.join(projectDir, 'lib', 'generated');
      final outputFile = File(path.join(outputDir, 'routes.dart'));

      // Create the output directory if it doesn't exist
      if (!Directory(outputDir).existsSync()) {
        Directory(outputDir).createSync(recursive: true);
      }

      // Generate the route registration code
      final buffer = StringBuffer();
      buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
      buffer.writeln('// Generated by Vortex Runner');
      buffer.writeln('// ');
      buffer.writeln('// To regenerate this file, run:');
      buffer.writeln('// vortex runner');
      buffer.writeln('');
      buffer.writeln('import \'package:vortex/vortex.dart\';');
      buffer.writeln('');

      // Track imported files to avoid duplicates
      final importedFiles = <String>{};

      // Import all page files
      for (final file in pageFiles) {
        final relativePath = path.relative(file.path, from: projectDir);
        final importPath = relativePath
            .replaceAll('\\', '/')
            .replaceFirst(RegExp(r'^lib/'), '');

        final importStatement =
            'import \'package:${_getPackageName(projectDir)}/$importPath\';';

        // Only add the import if we haven't seen it before
        if (importedFiles.add(importPath)) {
          buffer.writeln(importStatement);
        }
      }

      buffer.writeln('');
      buffer.writeln('/// Initialize all routes');
      buffer.writeln('void initializeRoutes() {');

      // Add route registration calls
      for (final file in pageFiles) {
        final content = file.readAsStringSync();
        final annotationMatch = RegExp(
          r'''@VortexPage\(\s*(['"])(.*?)\1\s*(?:,\s*middleware\s*:\s*\[(.*?)\])?\s*\)''',
        ).firstMatch(content);

        if (annotationMatch != null) {
          var routePath = annotationMatch.group(2)!;
          final middlewareStr = annotationMatch.group(3);

          // Normalize empty paths to root path '/'
          if (routePath.isEmpty) {
            routePath = '/';
          }

          // Parse middleware list if present
          List<String> middleware = [];
          if (middlewareStr != null && middlewareStr.isNotEmpty) {
            middleware =
                middlewareStr
                    .split(',')
                    .map(
                      (m) =>
                          m.trim().replaceAll(RegExp(r'''^['"]|['"]$'''), ''),
                    )
                    .where((m) => m.isNotEmpty)
                    .toList();
          }

          final classMatch = RegExp(
            r'class\s+(\w+)\s+extends\s+(StatelessWidget|StatefulWidget)',
          ).firstMatch(content);

          if (classMatch != null) {
            final className = classMatch.group(1)!;
            if (middleware.isNotEmpty) {
              buffer.writeln('  // Register route for $className');
              buffer.writeln('  VortexPageRegistry.registerPage(');
              buffer.writeln('    \'$routePath\',');
              buffer.writeln('    (context, args) => const $className(),');
              buffer.writeln(
                '    middleware: [${middleware.map((m) => '\'$m\'').join(', ')}],',
              );
              buffer.writeln('  );');
            } else {
              buffer.writeln('  // Register route for $className');
              buffer.writeln(
                '  VortexPageRegistry.registerPage(\'$routePath\', (context, args) => const $className());',
              );
            }
          }
        }
      }

      buffer.writeln('}');

      // Write the generated code to the output file
      outputFile.writeAsStringSync(buffer.toString());

      LogService.info("Generated route registration code: ${outputFile.path}");
      LogService.info("Add the following to your main.dart file:");
      LogService.info(
        "import 'package:${_getPackageName(projectDir)}/generated/routes.dart';",
      );
      LogService.info("void main() {");
      LogService.info("  initializeFlutterWindRoutes();");
      LogService.info("  runApp(const MyApp());");
      LogService.info("}");
    } catch (e, stackTrace) {
      LogService.error(
        "Error generating route registration code, error: $e, stackTrace: $stackTrace",
      );
    }
  }
}
