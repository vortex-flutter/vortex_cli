import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:vortex_cli/utils/logger.dart';

import '../../interface/command.dart';

class RunnerComponent extends Command {
  @override
  String get commandName => 'component';

  @override
  Future<void> execute() async {
    var componentName = this.name;
    final componentsDir =
        flags.contains('dir')
            ? _getArgValue('dir')
            : 'lib/components';
    final verbose = flags.contains('verbose') ? true : false;

    if (verbose) {
      LogService.info("Running Vortex component scanner...");
      LogService.info('Creating component $componentName in $componentsDir');
    }

    final projectDir = Directory.current.path;
    final fullComponentsDir = path.join(projectDir, componentsDir);

    try {
      final componentFiles = _findComponentFiles(fullComponentsDir);
      LogService.info("Found ${componentFiles.length} component files");

      if (verbose) {
        for (final file in componentFiles) {
          LogService.info(
            "Component file: ${path.relative(file.path, from: projectDir)}",
          );
        }
      }

      // Generate the component registration code
      _generateComponentRegistration(projectDir, componentFiles);
    } catch (e, stackTrace) {
      LogService.error(
        "Error running component scanner",
        error: e,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  String? get hint => 'Create a new component';

  @override
  int get maxParameters => 0;

  @override
  String? get codeSample => throw UnimplementedError();

  String _getArgValue(String flag) {
    final index = flags.indexOf(flag);
    if (index != -1 && index < flags.length - 1) {
      return flags[index + 1];
    }
    return '';
  }

  /// Find all component files in the given directory
  List<File> _findComponentFiles(String directory) {
    return Directory(directory)
        .listSync(recursive: true)
        .where(
          (entity) =>
              entity is File &&
              entity.path.endsWith('.dart') &&
              _containsComponentAnnotation(entity),
        )
        .cast<File>()
        .toList();
  }

  /// Check if a file contains the Component annotation
  bool _containsComponentAnnotation(File file) {
    try {
      final content = file.readAsStringSync();
      return content.contains('@Component');
    } catch (e) {
      LogService.error("Error reading file: ${file.path}", error: e);
      return false;
    }
  }

  /// Generate component registration code
  void _generateComponentRegistration(
    String projectDir,
    List<File> componentFiles,
  ) {
    try {
      final outputDir = path.join(projectDir, 'lib', 'generated');
      final outputFile = File(path.join(outputDir, 'components.dart'));

      // Create the output directory if it doesn't exist
      if (!Directory(outputDir).existsSync()) {
        Directory(outputDir).createSync(recursive: true);
      }

      // Generate the component registration code
      final buffer = StringBuffer();
      buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
      buffer.writeln('// Generated by Vortex Component Scanner');
      buffer.writeln('// ');
      buffer.writeln('// To regenerate this file, run:');
      buffer.writeln('// vortex runner components');
      buffer.writeln('');
      buffer.writeln('import \'package:flutter/widgets.dart\';');
      buffer.writeln('import \'package:vortex/vortex.dart\';');
      buffer.writeln('');

      // Track imported files to avoid duplicates
      final importedFiles = <String>{};

      // Import all component files
      for (final file in componentFiles) {
        final relativePath = path.relative(file.path, from: projectDir);
        final importPath = relativePath
            .replaceAll('\\', '/')
            .replaceFirst(RegExp(r'^lib/'), '');

        final importStatement =
            'import \'package:${_getPackageName(projectDir)}/$importPath\';';

        // Only add the import if we haven't seen it before
        if (importedFiles.add(importPath)) {
          buffer.writeln(importStatement);
        }
      }

      // Add additional imports that might be needed for component parameters
      buffer.writeln('import \'dart:ui\';');
      buffer.writeln('import \'package:flutter/material.dart\';');

      buffer.writeln('');
      buffer.writeln('/// Initialize all components');
      buffer.writeln('void initializeComponents() {');

      // Add component registration calls
      for (final file in componentFiles) {
        final content = file.readAsStringSync();

        // Extract class name
        final classMatch = RegExp(
          r'class\s+(\w+)\s+extends\s+StatelessWidget',
        ).firstMatch(content);

        if (classMatch != null) {
          final className = classMatch.group(1)!;
          buffer.writeln('  // Register component $className');
          buffer.writeln(
            '  ComponentRegistry.register(\'$className\', (props) {',
          );
          buffer.writeln('    // Convert props to the appropriate parameters');
          buffer.writeln('    return $className(');
          buffer.writeln('      key: props[\'key\'] as Key?,');

          // Extract constructor parameters by analyzing class fields
          final fieldRegex = RegExp(
            r'final\s+(\w+(?:<[^>]+>)?)\s+(\w+);',
            multiLine: true,
          );
          final fieldMatches = fieldRegex.allMatches(content);

          for (final match in fieldMatches) {
            final fieldType = match.group(1)!;
            final fieldName = match.group(2)!;

            if (fieldName != 'key') {
              // Skip the key field as it's already handled
              // Check if the field is required
              final isRequired = content.contains('required this.$fieldName');

              if (isRequired) {
                buffer.writeln(
                  '      $fieldName: props[\'$fieldName\'] as $fieldType,',
                );
              } else {
                buffer.writeln(
                  '      $fieldName: props[\'$fieldName\'] as $fieldType?,',
                );
              }
            }
          }

          buffer.writeln('    );');
          buffer.writeln('  });');
        }
      }

      buffer.writeln('}');

      // Write the generated code to the output file
      outputFile.writeAsStringSync(buffer.toString());

      LogService.info("Generated component registration code: ${outputFile.path}");
      LogService.info("Add the following to your main.dart file:");
      LogService.info(
        "import 'package:${_getPackageName(projectDir)}/generated/components.dart';",
      );
      LogService.info("void main() {");
      LogService.info("  initializeComponents();");
      LogService.info("  runApp(const MyApp());");
      LogService.info("}");
    } catch (e, stackTrace) {
      LogService.error(
        "Error generating component registration code",
        error: e,
        stackTrace: stackTrace,
      );
    }
  }

  /// Get the package name from pubspec.yaml
  String _getPackageName(String projectDir) {
    try {
      final pubspecFile = File(path.join(projectDir, 'pubspec.yaml'));

      if (pubspecFile.existsSync()) {
        final content = pubspecFile.readAsStringSync();
        final nameMatch = RegExp(r'name:\s*([^\s]+)').firstMatch(content);
        if (nameMatch != null) {
          return nameMatch.group(1)!;
        }
      }
    } catch (e) {
      LogService.error("Error getting package name", error: e);
    }

    return 'app';
  }
}
